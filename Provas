/*Sabendo que triângulo é uma figura geométrica de três lados onde cada um dos lados é
menor que a soma dos outros dois, escreva um programa em C, que receba três valores e
verifique e imprima se eles podem ser os comprimentos dos lados de um triângulo. */
int main()
{
    int lado1, lado2, lado3, soma1, soma2, soma3;
    
    printf("Digite os três valores dos lados (espaçados): ");
    scanf("%i" "%i" "%i", &lado1, &lado2, &lado3);
    
    soma1 = lado1 + lado2;
    soma2 = lado1 + lado3;
    soma3 = lado3 + lado2;
    
    if (soma1 > lado3){
        printf("Lado1 e lado2 podem ser os comprimentos dos lados de um triângulo\n");
    }
    else 
    {
        printf("Lado1 e lado2 não Podem ser os comprimentos dos lados de um triângulo\n");
    }
    
    if (soma2 > lado2){
        printf("Lado1 e lado3 podem ser os comprimentos dos lados de um triângulo\n");
    }
    else 
    {
        printf("Lado1 e lado3 não Podem ser os comprimentos dos lados de um triângulo\n"); 
    }
    
    if (soma3 > lado1){
        printf("Lado3 e lado2 podem ser os comprimentos dos lados de um triângulo\n");
    }
    else
    {
        printf("Lado3 e lado2 não Podem ser os comprimentos dos lados de um triângulo");
    }
}

/*O algoritmo ou fórmula de Luhn é um algoritmo para validação de números de
identificação. O maior uso do algoritmo de Luhn é na validação de números de cartões
de crédito. Contudo o algoritmo de Luhn pode ser utilizado em sequencia de números de
tamanho qualquer. Para a verificação do número o algoritmo se baseia nas seguintes
operações:
Dada uma sequência de números inteiros positivos (inclusive o dígito verificador), a
inverta. Em seguida, adicione o primeiro número a um somatório geral. Multiplique o
segundo número por 2 e execute a operação "noves fora", adicionando o resultado ao
somatório. Faça o mesmo com os demais números, ou seja ora adicione diretamente o
número ao somatório, ora o multiplique por 2, realizando "noves fora" e adicionando ao
somatório.
Por fim, verifique se o somatório é divisível por 10. Se for, o número é válido. Senão, é
inválido.Escreva um algoritmo em C que lê um número de até quatro dígitos e verifica se é um
número de identificação válido de acordo com a fórmula de Luhn e imprima “Número
Válido”ou “Número Inválido”conforme o caso.*/
int main()
{
  int num, num1, num2, num3, num4;

    printf("Insira um número de até 4 dígitos \n");
    scanf("%i", &num);

    num1 = num/1000;
    num2 = (num/100)%10;
    num3 = (num/10)%10;
    num4 = num%10;

    if (num >= 1000)
    {
        num1 = 2;
        num3= 2;
    } 

    else if (num>= 100)
    {
        num2 = 2;
        num4= 2;
    }

    else if (num>=10)
    {
        num3 = 2;
    }

    else if (num>=1)
    {
        num3= 2;
    }

    if (num1>9)
    {
        num1 -= 9;
    }
    if (num2>9)
    {
        num2 -= 9;
    }
    if (num3>9)
    {
        num3 -= 9;
    }
    if (num4>9)
    {
        num4 -= 9;
    }

    int soma = num1+num2+num3+num4;
    int verifc = soma%10;

    if (verifc == 0)
    {
        printf("Seu número é válido");
    }else{
        printf("Seu número é inváalido");
    }
}
/*Ao continuar sua jornada, Biu se depara com seu primeiro oponente: um incrível Rattata. Como Biu é bastante calculista, ele pede 
ajuda a você para descobrir se a sequência de ataques que ele pretende utilizar contra o seu oponente irá derrotá-lo, considerando que seu 
pokémon não morra antes. 
No jogo, Biu utilizará apenas três ataques e cada ataque corresponde a um número. Para o Rattata ser derrotado, dos três ataques selecionados 
por Biu, deve existir:  Um número maior que dez.  Um número par. 
Caso essas duas condições não forem satisfeitas, o Rattata não será derrotado. Outra observação é que se Biu escolher o ataque de número 
0, independente se as condições de vitória forem satisfeitas, o Rattata também não será derrotado.*/
int main()
{
    int ataque1, ataque2, ataque3;
        
        printf("Digite o valor dos 3 ataques: ");
        scanf("%i" "%i" "%i", &ataque1, &ataque2, &ataque3);
        
        if ((ataque1 > 10 || ataque2 > 10 || ataque3 > 10) && (ataque1 %2 == 0 || ataque2 %2 == 0 || ataque3 %2 == 0  ) && (ataque1 != 0 && ataque2 != 0 && ataque3 != 0)){
            printf("Você derrotou o Rattata");
        }else{
            printf("O Rattata não foi derrotado");
        }
}

